const jwt = require('jsonwebtoken');
const User = require('../models/User');
const GameModel = require('../models/Game');

// Stockage des connexions actives
const connectedUsers = new Map(); // socketId -> userId
const userSockets = new Map();    // userId -> Set of socketIds
const gameRooms = new Map();      // gameId -> Set of socketIds

/**
 * Gestionnaire principal des connexions Socket.IO
 * @param {SocketIO.Server} io - Instance Socket.IO
 */
const socketHandler = (io) => {
  // Middleware d'authentification pour Socket.IO
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      
      if (!token) {
        return next(new Error('Token d\'authentification requis'));
      }

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findById(decoded.userId).select('-password -refreshTokens');
      
      if (!user || !user.isActive) {
        return next(new Error('Utilisateur non trouv√© ou d√©sactiv√©'));
      }

      socket.userId = user._id.toString();
      socket.user = user;
      next();

    } catch (error) {
      next(new Error('Token invalide'));
    }
  });

  io.on('connection', (socket) => {
    console.log(`‚úÖ Utilisateur connect√©: ${socket.user.username} (${socket.id})`);
    
    // Enregistrer la connexion
    connectedUsers.set(socket.id, socket.userId);
    
    if (!userSockets.has(socket.userId)) {
      userSockets.set(socket.userId, new Set());
    }
    userSockets.get(socket.userId).add(socket.id);

    // Rejoindre les salons des parties actives
    joinActiveGameRooms(socket);

    // Gestionnaires d'√©v√©nements
    socket.on('game:join', (data) => handleGameJoin(socket, data));
    socket.on('game:leave', (data) => handleGameLeave(socket, data));
    socket.on('game:move', (data) => handleGameMove(socket, data));
    socket.on('game:resign', (data) => handleGameResign(socket, data));
    socket.on('game:draw-offer', (data) => handleDrawOffer(socket, data));
    socket.on('game:draw-response', (data) => handleDrawResponse(socket, data));
    socket.on('game:chat', (data) => handleGameChat(socket, data));
    socket.on('game:spectate', (data) => handleGameSpectate(socket, data));
    
    // Matchmaking
    socket.on('matchmaking:join', (data) => handleMatchmakingJoin(socket, data));
    socket.on('matchmaking:leave', () => handleMatchmakingLeave(socket));
    
    // Gestion de la d√©connexion
    socket.on('disconnect', () => handleDisconnect(socket));
  });
};

/**
 * Rejoindre les salons des parties actives de l'utilisateur
 * @param {Socket} socket - Socket de l'utilisateur
 */
const joinActiveGameRooms = async (socket) => {
  try {
    const activeGames = await GameModel.find({
      $or: [
        { 'players.white.user': socket.userId },
        { 'players.black.user': socket.userId }
      ],
      status: { $in: ['waiting', 'active'] }
    }).select('_id roomId');

    for (const game of activeGames) {
      const roomId = `game:${game._id}`;
      socket.join(roomId);
      
      if (!gameRooms.has(game._id.toString())) {
        gameRooms.set(game._id.toString(), new Set());
      }
      gameRooms.get(game._id.toString()).add(socket.id);
      
      console.log(`üë• ${socket.user.username} a rejoint le salon ${roomId}`);
    }
  } catch (error) {
    console.error('Erreur lors de la jointure des salons:', error);
  }
};

/**
 * Rejoindre une partie
 * @param {Socket} socket - Socket de l'utilisateur
 * @param {Object} data - Donn√©es de la partie
 */
const handleGameJoin = async (socket, data) => {
  try {
    const { gameId } = data;
    
    if (!gameId) {
      return socket.emit('error', { message: 'ID de partie requis' });
    }

    const game = await GameModel.findById(gameId).populate('players.white.user players.black.user');
    
    if (!game) {
      return socket.emit('error', { message: 'Partie non trouv√©e' });
    }

    // V√©rifier que l'utilisateur fait partie de la partie
    const isPlayer = game.players.white.user?._id.toString() === socket.userId ||
                    game.players.black.user?._id.toString() === socket.userId;

    if (!isPlayer) {
      return socket.emit('error', { message: 'Vous ne faites pas partie de cette partie' });
    }

    const roomId = `game:${gameId}`;
    socket.join(roomId);

    if (!gameRooms.has(gameId)) {
      gameRooms.set(gameId, new Set());
    }
    gameRooms.get(gameId).add(socket.id);

    // Notifier les autres joueurs
    socket.to(roomId).emit('game:player-joined', {
      userId: socket.userId,
      username: socket.user.username
    });

    // Envoyer l'√©tat de la partie
    socket.emit('game:state', {
      game: game.toObject()
    });

    console.log(`üéÆ ${socket.user.username} a rejoint la partie ${gameId}`);

  } catch (error) {
    console.error('Erreur lors de la jointure de partie:', error);
    socket.emit('error', { message: 'Erreur lors de la jointure de partie' });
  }
};

/**
 * Quitter une partie
 * @param {Socket} socket - Socket de l'utilisateur
 * @param {Object} data - Donn√©es de la partie
 */
const handleGameLeave = (socket, data) => {
  const { gameId } = data;
  
  if (!gameId) {
    return socket.emit('error', { message: 'ID de partie requis' });
  }

  const roomId = `game:${gameId}`;
  socket.leave(roomId);

  if (gameRooms.has(gameId)) {
    gameRooms.get(gameId).delete(socket.id);
    if (gameRooms.get(gameId).size === 0) {
      gameRooms.delete(gameId);
    }
  }

  // Notifier les autres joueurs
  socket.to(roomId).emit('game:player-left', {
    userId: socket.userId,
    username: socket.user.username
  });

  console.log(`üö™ ${socket.user.username} a quitt√© la partie ${gameId}`);
};

/**
 * Jouer un coup
 * @param {Socket} socket - Socket de l'utilisateur
 * @param {Object} data - Donn√©es du mouvement
 */
const handleGameMove = async (socket, data) => {
  try {
    const { gameId, move } = data;
    
    if (!gameId || !move) {
      return socket.emit('error', { message: 'Donn√©es de mouvement invalides' });
    }

    // TODO: Int√©grer avec le moteur de jeu
    // Pour l'instant, on simule la validation et l'ex√©cution
    
    const roomId = `game:${gameId}`;
    
    // √âmettre le mouvement √† tous les joueurs de la partie
    socket.to(roomId).emit('game:move', {
      playerId: socket.userId,
      move: move,
      timestamp: new Date()
    });

    // Confirmer au joueur qui a jou√©
    socket.emit('game:move-confirmed', {
      move: move,
      timestamp: new Date()
    });

    console.log(`‚ôüÔ∏è ${socket.user.username} a jou√© un coup dans la partie ${gameId}`);

  } catch (error) {
    console.error('Erreur lors du mouvement:', error);
    socket.emit('error', { message: 'Erreur lors du mouvement' });
  }
};

/**
 * Abandon de partie
 * @param {Socket} socket - Socket de l'utilisateur
 * @param {Object} data - Donn√©es de l'abandon
 */
const handleGameResign = async (socket, data) => {
  try {
    const { gameId } = data;
    
    if (!gameId) {
      return socket.emit('error', { message: 'ID de partie requis' });
    }

    const roomId = `game:${gameId}`;
    
    // Notifier tous les joueurs de l'abandon
    socket.to(roomId).emit('game:resigned', {
      playerId: socket.userId,
      username: socket.user.username,
      timestamp: new Date()
    });

    socket.emit('game:resign-confirmed', {
      timestamp: new Date()
    });

    console.log(`üè≥Ô∏è ${socket.user.username} a abandonn√© la partie ${gameId}`);

  } catch (error) {
    console.error('Erreur lors de l\'abandon:', error);
    socket.emit('error', { message: 'Erreur lors de l\'abandon' });
  }
};

/**
 * Proposition de nulle
 * @param {Socket} socket - Socket de l'utilisateur
 * @param {Object} data - Donn√©es de la proposition
 */
const handleDrawOffer = (socket, data) => {
  const { gameId } = data;
  
  if (!gameId) {
    return socket.emit('error', { message: 'ID de partie requis' });
  }

  const roomId = `game:${gameId}`;
  
  socket.to(roomId).emit('game:draw-offered', {
    playerId: socket.userId,
    username: socket.user.username,
    timestamp: new Date()
  });

  console.log(`ü§ù ${socket.user.username} propose une nulle dans la partie ${gameId}`);
};

/**
 * R√©ponse √† une proposition de nulle
 * @param {Socket} socket - Socket de l'utilisateur
 * @param {Object} data - Donn√©es de la r√©ponse
 */
const handleDrawResponse = (socket, data) => {
  const { gameId, accepted } = data;
  
  if (!gameId || typeof accepted !== 'boolean') {
    return socket.emit('error', { message: 'Donn√©es de r√©ponse invalides' });
  }

  const roomId = `game:${gameId}`;
  
  socket.to(roomId).emit('game:draw-response', {
    playerId: socket.userId,
    username: socket.user.username,
    accepted,
    timestamp: new Date()
  });

  const action = accepted ? 'accept√©' : 'refus√©';
  console.log(`ü§ù ${socket.user.username} a ${action} la nulle dans la partie ${gameId}`);
};

/**
 * Message de chat dans une partie
 * @param {Socket} socket - Socket de l'utilisateur
 * @param {Object} data - Donn√©es du message
 */
const handleGameChat = async (socket, data) => {
  try {
    const { gameId, message } = data;
    
    if (!gameId || !message || message.trim().length === 0) {
      return socket.emit('error', { message: 'Message invalide' });
    }

    if (message.length > 200) {
      return socket.emit('error', { message: 'Message trop long (200 caract√®res maximum)' });
    }

    const roomId = `game:${gameId}`;
    
    const chatMessage = {
      id: Date.now().toString(),
      userId: socket.userId,
      username: socket.user.username,
      message: message.trim(),
      timestamp: new Date()
    };

    // Envoyer √† tous les joueurs de la partie (y compris l'exp√©diteur)
    socket.to(roomId).emit('game:chat', chatMessage);
    socket.emit('game:chat', chatMessage);

    // TODO: Sauvegarder en base de donn√©es si n√©cessaire

  } catch (error) {
    console.error('Erreur lors de l\'envoi du message:', error);
    socket.emit('error', { message: 'Erreur lors de l\'envoi du message' });
  }
};

/**
 * Spectateur d'une partie
 * @param {Socket} socket - Socket du spectateur
 * @param {Object} data - Donn√©es de la partie √† regarder
 */
const handleGameSpectate = async (socket, data) => {
  try {
    const { gameId } = data;
    
    if (!gameId) {
      return socket.emit('error', { message: 'ID de partie requis' });
    }

    const game = await GameModel.findById(gameId).populate('players.white.user players.black.user');
    
    if (!game) {
      return socket.emit('error', { message: 'Partie non trouv√©e' });
    }

    const roomId = `game:${gameId}:spectators`;
    socket.join(roomId);

    // Envoyer l'√©tat de la partie au spectateur
    socket.emit('game:spectate-state', {
      game: game.toObject()
    });

    // Notifier les autres spectateurs
    socket.to(roomId).emit('game:spectator-joined', {
      userId: socket.userId,
      username: socket.user.username
    });

    console.log(`üëÅÔ∏è ${socket.user.username} regarde la partie ${gameId}`);

  } catch (error) {
    console.error('Erreur lors du spectating:', error);
    socket.emit('error', { message: 'Erreur lors du spectating' });
  }
};

/**
 * Rejoindre la file d'attente de matchmaking
 * @param {Socket} socket - Socket de l'utilisateur
 * @param {Object} data - Pr√©f√©rences de matchmaking
 */
const handleMatchmakingJoin = (socket, data) => {
  const { timeControl = 900, gameType = 'classic' } = data;
  
  socket.join('matchmaking');
  
  socket.matchmakingPrefs = {
    timeControl,
    gameType,
    rating: socket.user.rating.current,
    joinedAt: new Date()
  };

  socket.emit('matchmaking:joined', {
    message: 'Recherche d\'adversaire en cours...',
    preferences: socket.matchmakingPrefs
  });

  // TODO: Impl√©menter la logique de matchmaking
  console.log(`üîç ${socket.user.username} recherche un adversaire`);
};

/**
 * Quitter la file d'attente de matchmaking
 * @param {Socket} socket - Socket de l'utilisateur
 */
const handleMatchmakingLeave = (socket) => {
  socket.leave('matchmaking');
  delete socket.matchmakingPrefs;
  
  socket.emit('matchmaking:left', {
    message: 'Recherche annul√©e'
  });

  console.log(`‚ùå ${socket.user.username} a annul√© la recherche`);
};

/**
 * Gestion de la d√©connexion
 * @param {Socket} socket - Socket qui se d√©connecte
 */
const handleDisconnect = (socket) => {
  console.log(`‚ùå Utilisateur d√©connect√©: ${socket.user.username} (${socket.id})`);
  
  // Nettoyer les r√©f√©rences
  connectedUsers.delete(socket.id);
  
  if (userSockets.has(socket.userId)) {
    userSockets.get(socket.userId).delete(socket.id);
    if (userSockets.get(socket.userId).size === 0) {
      userSockets.delete(socket.userId);
    }
  }

  // Nettoyer les salons de jeu
  for (const [gameId, socketSet] of gameRooms.entries()) {
    if (socketSet.has(socket.id)) {
      socketSet.delete(socket.id);
      if (socketSet.size === 0) {
        gameRooms.delete(gameId);
      }
    }
  }

  // Quitter le matchmaking si n√©cessaire
  if (socket.matchmakingPrefs) {
    handleMatchmakingLeave(socket);
  }
};

/**
 * Utilitaires pour l'interaction avec Socket.IO depuis d'autres parties du code
 */
const socketUtils = {
  /**
   * √âmettre un √©v√©nement √† tous les sockets d'un utilisateur
   * @param {string} userId - ID de l'utilisateur
   * @param {string} event - Nom de l'√©v√©nement
   * @param {Object} data - Donn√©es √† envoyer
   */
  emitToUser: (userId, event, data) => {
    if (userSockets.has(userId)) {
      for (const socketId of userSockets.get(userId)) {
        const socket = io.sockets.sockets.get(socketId);
        if (socket) {
          socket.emit(event, data);
        }
      }
    }
  },

  /**
   * √âmettre un √©v√©nement √† tous les joueurs d'une partie
   * @param {string} gameId - ID de la partie
   * @param {string} event - Nom de l'√©v√©nement
   * @param {Object} data - Donn√©es √† envoyer
   */
  emitToGame: (gameId, event, data) => {
    if (gameRooms.has(gameId)) {
      for (const socketId of gameRooms.get(gameId)) {
        const socket = io.sockets.sockets.get(socketId);
        if (socket) {
          socket.emit(event, data);
        }
      }
    }
  },

  /**
   * V√©rifier si un utilisateur est en ligne
   * @param {string} userId - ID de l'utilisateur
   * @returns {boolean} True si en ligne
   */
  isUserOnline: (userId) => {
    return userSockets.has(userId) && userSockets.get(userId).size > 0;
  },

  /**
   * Obtenir le nombre d'utilisateurs connect√©s
   * @returns {number} Nombre d'utilisateurs en ligne
   */
  getOnlineCount: () => {
    return userSockets.size;
  }
};

module.exports = socketHandler;
module.exports.socketUtils = socketUtils;